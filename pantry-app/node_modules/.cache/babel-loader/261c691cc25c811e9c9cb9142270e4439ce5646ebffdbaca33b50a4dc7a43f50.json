{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useAppData.js\nimport { useEffect, useState } from \"react\";\nimport { parseCSV, normalizeName } from \"../utils/csv\";\nexport function useAppData() {\n  _s();\n  const [recipes, setRecipes] = useState([]);\n  const [allIngredients, setAllIngredients] = useState([]);\n  const [ingredientCategoryMap, setIngredientCategoryMap] = useState(new Map());\n  const [selected, setSelected] = useState(new Set());\n  const [loading, setLoading] = useState(true);\n  const [loadErr, setLoadErr] = useState(\"\");\n\n  // restore pantry\n  useEffect(() => {\n    try {\n      const raw = localStorage.getItem(\"selectedIngredients\");\n      if (raw) setSelected(new Set(JSON.parse(raw)));\n    } catch {}\n  }, []);\n\n  // persist pantry\n  useEffect(() => {\n    try {\n      localStorage.setItem(\"selectedIngredients\", JSON.stringify(Array.from(selected)));\n    } catch {}\n  }, [selected]);\n\n  // load CSVs\n  useEffect(() => {\n    async function load() {\n      try {\n        setLoading(true);\n        const BASE = process.env.PUBLIC_URL || \"\";\n        const [recRes, ingRes] = await Promise.all([fetch(`${BASE}/data/recipes.csv`), fetch(`${BASE}/data/ingredients.csv`)]);\n        if (!recRes.ok) throw new Error(\"Failed to fetch recipes.csv\");\n        if (!ingRes.ok) throw new Error(\"Failed to fetch ingredients.csv\");\n        const [recTxt, ingTxt] = await Promise.all([recRes.text(), ingRes.text()]);\n        const recRows = parseCSV(recTxt);\n        const ingRows = parseCSV(ingTxt);\n        const recipesParsed = recRows.map(r => ({\n          title: r.title,\n          category: r.category,\n          time: Number(r.time),\n          ingredients: (r.ingredients || []).map(normalizeName)\n        }));\n        const catMap = new Map();\n        ingRows.forEach(row => {\n          const name = normalizeName(row.name);\n          const cat = normalizeName(row.category || \"other\") || \"other\";\n          if (name) catMap.set(name, cat);\n        });\n        const ingSet = new Set();\n        recipesParsed.forEach(r => r.ingredients.forEach(i => ingSet.add(i)));\n        ingSet.forEach(i => {\n          if (!catMap.has(i)) catMap.set(i, \"other\");\n        });\n        setIngredientCategoryMap(catMap);\n        setAllIngredients(Array.from(ingSet).sort());\n        setRecipes(recipesParsed);\n        setLoadErr(\"\");\n      } catch (e) {\n        setLoadErr(e.message || \"Unknown load error\");\n      } finally {\n        setLoading(false);\n      }\n    }\n    load();\n  }, []);\n  function toggleIngredient(name) {\n    const n = normalizeName(name);\n    setSelected(prev => {\n      const next = new Set(prev);\n      if (next.has(n)) next.delete(n);else next.add(n);\n      return next;\n    });\n  }\n  return {\n    recipes,\n    allIngredients,\n    ingredientCategoryMap,\n    selected,\n    toggleIngredient,\n    loading,\n    loadErr\n  };\n}\n_s(useAppData, \"jOUk6sltTv9l3stYMku0b1qnP5E=\");","map":{"version":3,"names":["useEffect","useState","parseCSV","normalizeName","useAppData","_s","recipes","setRecipes","allIngredients","setAllIngredients","ingredientCategoryMap","setIngredientCategoryMap","Map","selected","setSelected","Set","loading","setLoading","loadErr","setLoadErr","raw","localStorage","getItem","JSON","parse","setItem","stringify","Array","from","load","BASE","process","env","PUBLIC_URL","recRes","ingRes","Promise","all","fetch","ok","Error","recTxt","ingTxt","text","recRows","ingRows","recipesParsed","map","r","title","category","time","Number","ingredients","catMap","forEach","row","name","cat","set","ingSet","i","add","has","sort","e","message","toggleIngredient","n","prev","next","delete"],"sources":["/Users/leonor/Dev/recipes/pantry-app/src/hooks/useAppData.js"],"sourcesContent":["// src/hooks/useAppData.js\nimport { useEffect, useState } from \"react\";\nimport { parseCSV, normalizeName } from \"../utils/csv\";\n\nexport function useAppData() {\n  const [recipes, setRecipes] = useState([]);\n  const [allIngredients, setAllIngredients] = useState([]);\n  const [ingredientCategoryMap, setIngredientCategoryMap] = useState(new Map());\n  const [selected, setSelected] = useState(new Set());\n  const [loading, setLoading] = useState(true);\n  const [loadErr, setLoadErr] = useState(\"\");\n\n  // restore pantry\n  useEffect(() => {\n    try {\n      const raw = localStorage.getItem(\"selectedIngredients\");\n      if (raw) setSelected(new Set(JSON.parse(raw)));\n    } catch {}\n  }, []);\n\n  // persist pantry\n  useEffect(() => {\n    try {\n      localStorage.setItem(\"selectedIngredients\", JSON.stringify(Array.from(selected)));\n    } catch {}\n  }, [selected]);\n\n  // load CSVs\n  useEffect(() => {\n    async function load() {\n      try {\n        setLoading(true);\n        const BASE = process.env.PUBLIC_URL || \"\";\n        const [recRes, ingRes] = await Promise.all([\n          fetch(`${BASE}/data/recipes.csv`),\n          fetch(`${BASE}/data/ingredients.csv`),\n        ]);\n\n        if (!recRes.ok) throw new Error(\"Failed to fetch recipes.csv\");\n        if (!ingRes.ok) throw new Error(\"Failed to fetch ingredients.csv\");\n\n        const [recTxt, ingTxt] = await Promise.all([recRes.text(), ingRes.text()]);\n        const recRows = parseCSV(recTxt);\n        const ingRows = parseCSV(ingTxt);\n\n        const recipesParsed = recRows.map((r) => ({\n          title: r.title,\n          category: r.category,\n          time: Number(r.time),\n          ingredients: (r.ingredients || []).map(normalizeName),\n        }));\n\n        const catMap = new Map();\n        ingRows.forEach((row) => {\n          const name = normalizeName(row.name);\n          const cat = normalizeName(row.category || \"other\") || \"other\";\n          if (name) catMap.set(name, cat);\n        });\n\n        const ingSet = new Set();\n        recipesParsed.forEach((r) => r.ingredients.forEach((i) => ingSet.add(i)));\n        ingSet.forEach((i) => {\n          if (!catMap.has(i)) catMap.set(i, \"other\");\n        });\n\n        setIngredientCategoryMap(catMap);\n        setAllIngredients(Array.from(ingSet).sort());\n        setRecipes(recipesParsed);\n        setLoadErr(\"\");\n      } catch (e) {\n        setLoadErr(e.message || \"Unknown load error\");\n      } finally {\n        setLoading(false);\n      }\n    }\n    load();\n  }, []);\n\n  function toggleIngredient(name) {\n    const n = normalizeName(name);\n    setSelected((prev) => {\n      const next = new Set(prev);\n      if (next.has(n)) next.delete(n);\n      else next.add(n);\n      return next;\n    });\n  }\n\n  return {\n    recipes,\n    allIngredients,\n    ingredientCategoryMap,\n    selected,\n    toggleIngredient,\n    loading,\n    loadErr,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}